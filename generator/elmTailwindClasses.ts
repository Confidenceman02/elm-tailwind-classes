import {
  existsSync,
  mkdirSync,
  promises as fsPromises,
  unlinkSync,
} from "node:fs";
import { resolve } from "node:path";
import { Readable, Stream } from "node:stream";
import * as R from "rambda";
import * as glob from "glob";

const resolveConfig = require("tailwindcss/resolveConfig");
const DEFAULT_TW_CONFIG = "tailwind.config.js";
const ELM_TAILWIND_CLASSES_PACKAGE_BASE = "TailwindClasses";
const CURRENT_DIR = __dirname;
const MODULE_COMMENT = `-- Do not manually edit this file, it was auto-generated by @Confidenceman02/postcss-elm-tailwind-classes
--https://github.com/Confidenceman02/postcss-elm-tailwind-classes
`;
const SCREEN_VARIANTS = ["sm", "md", "lg", "xl", "2xl"];
const MODIFIER_VARIANTS = [
  "first",
  "last",
  "only",
  "odd",
  "even",
  "first-of-type",
  "last-of-type",
  "only-of-type",
  "visited",
  "target",
  "open",
  "default",
  "checked",
  "indeterminate",
  "placeholder-shown",
  "autofill",
  "optional",
  "required",
  "valid",
  "invalid",
  "in-range",
  "out-of-range",
  "read-only",
  "empty",
  "focus-within",
  "hover",
  "focus",
  "focus-visible",
  "active",
  "enabled",
  "disabled",
  "before",
  "after",
  "placeholder",
  "file",
  "marker",
  "selection",
  "first-line",
  "first-letter",
  "backdrop",
  // DARK
  "dark",
];

type ThemeKeyToModule = {
  backgroundAttachment: "Background";
  backgroundClip: "Background";
  backgroundColor: "Background";
  backgroundOrigin: "Background";
  backgroundPosition: "Background";
  backgroundRepeat: "Background";
  backgroundSize: "Background";
  backgroundImage: "Background";
  // TODO gradient color stops map to from-fixed-<*>
  // gradientColorStops: "Background";
  margin: "Spacing";
};

const THEME_KEY_TO_MODULE: ThemeKeyToModule = {
  backgroundAttachment: "Background",
  backgroundClip: "Background",
  backgroundColor: "Background",
  backgroundOrigin: "Background",
  backgroundPosition: "Background",
  backgroundRepeat: "Background",
  backgroundSize: "Background",
  backgroundImage: "Background",
  // gradientColorStops: "Background",
  margin: "Spacing",
};

type ModuleToUtility = {
  Background: "bg";
};
const MODULE_TO_UTILITY = {
  Background: "bg",
};

type Options = {
  config: string;
  base: string;
  output: string;
  utilities: Array<ThemeKeyToModule[keyof ThemeKeyToModule]>;
};

const defaultOptions = {
  config: DEFAULT_TW_CONFIG,
  base: "TW",
  output: "src",
  utilities: [],
};

function resolveElmModules(opts: Options = defaultOptions) {
  if (opts.utilities.length <= 0) {
    console.warn(
      "[elm-tailwind-classes]: No utilities specified in config. No elm modules will be generated."
    );
    return;
  }

  let configPath = DEFAULT_TW_CONFIG;
  if (opts.config && existsSync(resolve(CURRENT_DIR, opts.config))) {
    const p = resolve(CURRENT_DIR, opts.config);
    console.log(`Found config at: ${p}`);
    configPath = p;
  }

  if (!configPath) {
    const p = resolve(CURRENT_DIR, DEFAULT_TW_CONFIG);
    if (existsSync(p)) {
      console.log(`No config value set but Found config at: ${p}`);
      configPath = p;
    } else {
      console.log(
        `Couldn't find a tailwind configuration file.\nI was looking for one at: ${resolve(
          CURRENT_DIR,
          DEFAULT_TW_CONFIG
        )}`
      );
      return;
    }
  }

  const TW_BASE = `${opts.output}/${opts.base}`;

  const RESOLVED_TW_BASE = resolve(CURRENT_DIR, TW_BASE);

  const twConfig = require(configPath);

  const resolvedConfig: {
    theme: { [P in keyof ThemeKeyToModule]: Array<any> };
    separator: string;
  } = resolveConfig(twConfig);

  const allActions = [
    // CLEAN DIRECTORY
    removeGenerated(RESOLVED_TW_BASE),
    // BASE DIRECTORY
    mkdir(RESOLVED_TW_BASE),
    // MODIFIER MODULE
    R.pipe(
      prepareModifierFile,
      writeFile(resolve(CURRENT_DIR, TW_BASE, "Modifier.elm"))
    )(
      opts.base,
      resolvedConfig.separator,
      "Modifier",
      MODIFIER_VARIANTS,
      modifierFunctionString
    ),
    // SCREEN MODULE
    R.pipe(
      prepareModifierFile,
      writeFile(resolve(CURRENT_DIR, TW_BASE, "Screen.elm"))
    )(
      opts.base,
      resolvedConfig.separator,
      "Screen",
      SCREEN_VARIANTS,
      screenFunctionString
    ),
    // UTILITY MODULES
    R.pipe(
      collectUtilities,
      prepareRawUtilityClasses,
      prepareUtilityFiles(opts.base),
      writeFiles(resolve(CURRENT_DIR, TW_BASE))
    )(resolvedConfig.theme, opts.utilities),
  ];

  return Promise.all(allActions).then(() =>
    console.log("Create Tailwind elm modules")
  );
}

function removeGenerated(baseDir: string) {
  glob.sync(baseDir + "/**/*.elm").forEach(unlinkSync);
}

function prepareModifierFile(
  base: string,
  separator: string,
  module: string,
  modifiers: string[],
  fileAdder: (safeValue: string) => string
) {
  const file = [
    MODULE_COMMENT,
    moduleRootString(`${base}.${module}`),
    importString(ELM_TAILWIND_CLASSES_PACKAGE_BASE),
    "\u000A",
    simpleElmFunction({
      name: "separator",
      type: "String",
      body: `"${separator}"`,
    }),
    "\u000A",
  ];
  let i = 0;
  while (i < modifiers.length) {
    const variant = modifiers[i++];
    file.push(fileAdder(variant));
  }
  return Readable.from(file);
}

function prepareUtilityFiles(base: string) {
  return function (twClasses: Map<string, string[]>) {
    const files: Map<string, Stream> = new Map();
    twClasses.forEach((v, k) => {
      const file = [
        MODULE_COMMENT,
        moduleRootString(`${base}.${k}`),
        importString(ELM_TAILWIND_CLASSES_PACKAGE_BASE),
        "\u000A",
      ];
      let count1 = 0;

      while (count1 < v.length) {
        const twClass = v[count1++];
        const elmName = R.pipe(replaceKebabsWithSnakes)(twClass);
        file.push(
          simpleElmFunction({
            name: elmName,
            type: "Class",
            body: `Utility "${twClass}"`,
          })
        );
      }
      files.set(k, Readable.from(file));
    });
    return files;
  };
}

function prepareRawUtilityClasses(moduleMap: Map<keyof ModuleToUtility, any>) {
  const functionsMap = new Map();
  moduleMap.forEach((v, k) => {
    const builtClasses: string[] = [];
    const utilityKey = MODULE_TO_UTILITY[k];

    let count1 = 0;
    while (count1 < v.length) {
      const data1 = v[count1++];
      function buildFile(
        rootKey: string,
        data2: {
          key: string;
          values: Array<string | { key: string; values: any }>;
        }
      ) {
        let count2 = 0;
        while (count2 < data2.values.length) {
          const rawValue = data2.values[count2++];

          typeof rawValue === "string"
            ? builtClasses.push(`${rootKey}-${rawValue}`)
            : buildFile(`${rootKey}-${rawValue.key}`, rawValue);
        }
      }
      buildFile(utilityKey, data1);
    }
    functionsMap.set(k, builtClasses);
  });
  return functionsMap;
}

function collectUtilities(
  theme: { [P in keyof ThemeKeyToModule]: Array<any> },
  userUtilities: string[]
) {
  const ELM_UTILITY_MODULES: Map<keyof ModuleToUtility, Array<any>> = new Map();
  Object.entries(theme).forEach(([themeKey, themeValues]) => {
    const key = THEME_KEY_TO_MODULE[themeKey as keyof ThemeKeyToModule];

    if (key && userUtilities.includes(key)) {
      const currentUtilities: Array<{ key: string; values: Array<any> }> =
        ELM_UTILITY_MODULES.get(key as keyof ModuleToUtility) || [];
      currentUtilities.push(
        recursiveThemeValues(
          themeValues,
          MODULE_TO_UTILITY[key as keyof ModuleToUtility]
        )
      );
      ELM_UTILITY_MODULES.set(
        THEME_KEY_TO_MODULE[
          themeKey as keyof ThemeKeyToModule
        ] as keyof ModuleToUtility,
        currentUtilities
      );
    }
  });
  return ELM_UTILITY_MODULES;
}

function recursiveThemeValues(vals: Object, utilityKey: string) {
  function buildValues(obj: { [k: string]: any }, utilKey: string) {
    const allValues: { key: string; values: Array<any> } = {
      key: utilKey,
      values: [],
    };
    const keys = Object.keys(obj);
    let i = 0;

    // Assuming there are no nested Arrays
    while (i < keys.length) {
      const unsafeKey = keys[i++];

      // We want to always make sure "some-utility-class" turns into
      // "some_utlitiy_class"
      const valueType = typeof obj[unsafeKey];

      allValues.values.push(
        valueType === "string"
          ? unsafeKey
          : buildValues(obj[unsafeKey], unsafeKey)
      );
    }
    return allValues;
  }
  return buildValues(vals, utilityKey);
}

function transformLeadingInt(val: string) {
  const regex = /^[0-9]+/;
  const reg = new RegExp(regex);

  if (reg.test(val)) {
    const rest = R.pipe(R.reject(R.isEmpty))(val.split(regex));
    const foundInt = val.match(regex) || "";

    if (0 < rest.length) {
      const safeFunction = `${rest.reduce(
        (acc, curr) => acc + curr
      )}${foundInt}`;
      return safeFunction;
    }
  }
  return val;
}

function transformFraction(val: string) {
  const reg = new RegExp(/([0-9]*[/])[0-9]+/);
  if (reg.test(val)) {
    return val.replace(/\//g, "_slash_");
  }
  return val;
}

function transformFloat(val: string) {
  const reg = new RegExp(/([0-9]*[.])[0-9]+/);
  if (reg.test(val)) {
    return val.replace(/\./g, "_dot_");
  }
  return val;
}

function replaceKebabsWithSnakes(val: string) {
  return val.replace(/-/g, "_");
}

// IO

async function mkdir(dirPath: string) {
  return mkdirSync(dirPath, { recursive: true });
}

function writeFiles(baseDir: string) {
  return async function (data: Map<string, Stream>) {
    const writePromises: Array<Promise<void>> = [];
    data.forEach((v, k) => {
      writePromises.push(fsPromises.writeFile(`${baseDir}/${k}.elm`, v));
    });

    await Promise.allSettled(writePromises);
  };
}

function writeFile(dirPath: string) {
  return async function (data: Stream) {
    await fsPromises.writeFile(dirPath, data);
  };
}

// ELM MODULE BODY

function moduleRootString(moduleName: string) {
  return `module ${moduleName} exposing (..)
  
`;
}

function importString(moduleName: string) {
  return `import ${moduleName} exposing (..)
`;
}

function simpleElmFunction(body: { name: string; type: string; body: string }) {
  return `${body.name} : ${body.type}
${body.name} = ${body.body}\n\n`;
}

function elmFunctionWithArgs(expression: {
  name: string;
  types: string[];
  args: string[];
  body: string;
}) {
  const types = expression.types.reduce((acc, curr) => acc + " -> " + curr);
  const args = expression.args.reduce((acc, curr) => acc + " " + curr);

  return `
${expression.name} : ${types}
${expression.name} ${args} =
  ${expression.body}

`;
}

function modifierBody(expression: { class: string; variant: string }) {
  return `  case ${expression.class} of
      Utility u -> Modifier (\u005C_ -> "${expression.variant}" ++ separator ++ u)
      Modifier fn -> Modifier (\u005C_ -> "${expression.variant}" ++ separator ++ fn ())`;
}

function modifierFunctionString(unsafeValue: string) {
  const safeVariant = R.pipe(replaceKebabsWithSnakes)(unsafeValue);
  return elmFunctionWithArgs({
    name: safeVariant,
    types: ["Class", "Class"],
    args: ["cls"],
    body: modifierBody({ class: "cls", variant: unsafeValue }),
  });
}

function screenFunctionString(unsafeValue: string) {
  const safeVariant = R.pipe(
    transformLeadingInt,
    replaceKebabsWithSnakes
  )(unsafeValue);
  return simpleElmFunction({
    name: safeVariant,
    type: "Class",
    body: `Utility "${unsafeValue}"`,
  });
}

export default resolveElmModules;
